use anyhow::Result;
use std::path::Path;

use crate::traits::FileSystem;

use super::index::RegistryIndex;

/// Generate HTML page for registry index
pub fn generate_html(index: &RegistryIndex) -> String {
    let title = format!("{} - PMP Template Registry", index.metadata.name);
    let description = index
        .metadata
        .description
        .clone()
        .unwrap_or_else(|| "PMP Template Pack Registry".to_string());

    let pack_cards = generate_pack_cards(&index.packs);

    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{title}</title>
  <meta name="description" content="{description}">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .pack-card:hover {{ transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }}
    .copy-btn:hover {{ background-color: #4F46E5; color: white; }}
    .tag {{ transition: all 0.2s; }}
    .tag:hover {{ background-color: #4F46E5; color: white; }}
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <header class="bg-indigo-600 text-white py-8">
    <div class="max-w-6xl mx-auto px-4">
      <h1 class="text-3xl font-bold">{title}</h1>
      <p class="mt-2 text-indigo-200">{description}</p>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-8">
    <div class="mb-6">
      <input type="text" id="search" placeholder="Search template packs..."
             class="w-full p-4 rounded-lg border border-gray-300 shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
    </div>

    <div class="mb-4 text-gray-600">
      <span id="pack-count">{pack_count}</span> template packs available
    </div>

    <div id="packs" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {pack_cards}
    </div>
  </main>

  <footer class="bg-gray-100 py-6 mt-12">
    <div class="max-w-6xl mx-auto px-4 text-center text-gray-600">
      <p>Generated by <a href="https://github.com/pmp-project/pmp-cli" class="text-indigo-600 hover:underline">PMP CLI</a></p>
      {generated_at}
    </div>
  </footer>

  <script>
    // Search functionality
    const searchInput = document.getElementById('search');
    const packsContainer = document.getElementById('packs');
    const packCount = document.getElementById('pack-count');
    const allCards = Array.from(packsContainer.querySelectorAll('.pack-card'));

    searchInput.addEventListener('input', function() {{
      const query = this.value.toLowerCase();
      let visibleCount = 0;

      allCards.forEach(card => {{
        const name = card.dataset.name.toLowerCase();
        const description = (card.dataset.description || '').toLowerCase();
        const tags = (card.dataset.tags || '').toLowerCase();

        const matches = name.includes(query) || description.includes(query) || tags.includes(query);
        card.style.display = matches ? 'block' : 'none';

        if (matches) visibleCount++;
      }});

      packCount.textContent = visibleCount;
    }});

    // Copy to clipboard
    function copyToClipboard(text, btn) {{
      navigator.clipboard.writeText(text).then(() => {{
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        btn.classList.add('bg-green-500', 'text-white');
        setTimeout(() => {{
          btn.textContent = originalText;
          btn.classList.remove('bg-green-500', 'text-white');
        }}, 2000);
      }});
    }}
  </script>
</body>
</html>"#,
        title = title,
        description = description,
        pack_count = index.packs.len(),
        pack_cards = pack_cards,
        generated_at = index
            .metadata
            .generated_at
            .map(|dt| format!(
                "<p class=\"text-sm mt-2\">Last updated: {}</p>",
                dt.format("%Y-%m-%d %H:%M:%S UTC")
            ))
            .unwrap_or_default(),
    )
}

/// Generate HTML cards for packs
fn generate_pack_cards(packs: &[super::index::PackInfo]) -> String {
    packs
        .iter()
        .map(|pack| generate_pack_card(pack))
        .collect::<Vec<_>>()
        .join("\n")
}

/// Generate a single pack card
fn generate_pack_card(pack: &super::index::PackInfo) -> String {
    let description = pack
        .description
        .clone()
        .unwrap_or_else(|| "No description available".to_string());

    let tags_html = pack
        .tags
        .iter()
        .map(|tag| {
            format!(
                r#"<span class="tag inline-block bg-gray-200 rounded-full px-3 py-1 text-sm text-gray-700 mr-2 mb-2 cursor-pointer">{}</span>"#,
                tag
            )
        })
        .collect::<Vec<_>>()
        .join("");

    let latest_version = pack
        .latest_version()
        .map(|v| v.version.clone())
        .unwrap_or_else(|| "latest".to_string());

    let version_options = pack
        .versions
        .iter()
        .map(|v| format!(r#"<option value="{}">{}</option>"#, v.version, v.version))
        .collect::<Vec<_>>()
        .join("");

    let install_cmd = format!("pmp marketplace install {}", pack.name);
    let tags_data = pack.tags.join(",");

    format!(
        r##"<div class="pack-card bg-white rounded-lg shadow-md p-6 transition-all duration-200"
         data-name="{name}"
         data-description="{description}"
         data-tags="{tags_data}">
      <div class="flex justify-between items-start mb-4">
        <h2 class="text-xl font-semibold text-gray-800">{name}</h2>
        {author_badge}
      </div>

      <p class="text-gray-600 mb-4 line-clamp-2">{description}</p>

      <div class="mb-4">
        {tags_html}
      </div>

      <div class="flex items-center gap-2 mb-4">
        <label class="text-sm text-gray-500">Version:</label>
        <select id="version-{name}" class="text-sm border rounded px-2 py-1">
          {version_options}
        </select>
      </div>

      <div class="flex items-center gap-2 bg-gray-100 rounded p-2">
        <code class="text-sm text-gray-700 flex-grow overflow-x-auto">{install_cmd}</code>
        <button onclick="copyToClipboard('{install_cmd}', this)"
                class="copy-btn text-xs bg-gray-200 hover:bg-indigo-600 hover:text-white px-2 py-1 rounded transition-colors">
          Copy
        </button>
      </div>

      <div class="mt-4 flex justify-between items-center text-sm">
        <a href="{repository}" target="_blank" rel="noopener"
           class="text-indigo-600 hover:underline">View Repository â†’</a>
        {license_badge}
      </div>
    </div>"##,
        name = pack.name,
        description = description,
        tags_data = tags_data,
        tags_html = if tags_html.is_empty() {
            r#"<span class="text-gray-400 text-sm">No tags</span>"#.to_string()
        } else {
            tags_html
        },
        version_options = if version_options.is_empty() {
            r#"<option value="latest">latest</option>"#.to_string()
        } else {
            version_options
        },
        install_cmd = install_cmd,
        repository = pack.repository,
        author_badge = pack
            .author
            .as_ref()
            .map(|a| format!(
                r#"<span class="text-sm text-gray-500">by {}</span>"#,
                a
            ))
            .unwrap_or_default(),
        license_badge = pack
            .license
            .as_ref()
            .map(|l| format!(
                r#"<span class="text-gray-500">{}</span>"#,
                l
            ))
            .unwrap_or_default(),
    )
}

/// Write index files to output directory
pub fn write_index_files(
    fs: &dyn FileSystem,
    output_dir: &Path,
    index: &RegistryIndex,
) -> Result<()> {
    // Create output directory
    fs.create_dir_all(output_dir)?;

    // Write index.json
    let json_path = output_dir.join("index.json");
    let json_content = serde_json::to_string_pretty(index)?;
    fs.write(&json_path, &json_content)?;

    // Write index.html
    let html_path = output_dir.join("index.html");
    let html_content = generate_html(index);
    fs.write(&html_path, &html_content)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::marketplace::index::{PackInfo, PackVersion};
    use crate::traits::MockFileSystem;

    fn create_test_index() -> RegistryIndex {
        let pack1 = PackInfo::new("aws-vpc", "https://github.com/test/aws-vpc")
            .with_description("AWS VPC templates")
            .with_author("test-org")
            .with_license("MIT")
            .with_tags(vec!["aws".to_string(), "networking".to_string()])
            .with_versions(vec![
                PackVersion::new("2.0.0"),
                PackVersion::new("1.0.0"),
            ]);

        let pack2 = PackInfo::new("azure-vnet", "https://github.com/test/azure-vnet")
            .with_description("Azure Virtual Network templates")
            .with_tags(vec!["azure".to_string(), "networking".to_string()])
            .with_versions(vec![PackVersion::new("1.0.0")]);

        RegistryIndex::new("test-registry", Some("Test Registry"))
            .with_packs(vec![pack1, pack2])
    }

    #[test]
    fn test_generate_html_contains_title() {
        let index = create_test_index();
        let html = generate_html(&index);

        assert!(html.contains("test-registry - PMP Template Registry"));
        assert!(html.contains("Test Registry"));
    }

    #[test]
    fn test_generate_html_contains_packs() {
        let index = create_test_index();
        let html = generate_html(&index);

        assert!(html.contains("aws-vpc"));
        assert!(html.contains("azure-vnet"));
        assert!(html.contains("AWS VPC templates"));
    }

    #[test]
    fn test_generate_html_contains_search() {
        let index = create_test_index();
        let html = generate_html(&index);

        assert!(html.contains("id=\"search\""));
        assert!(html.contains("Search template packs"));
    }

    #[test]
    fn test_generate_html_contains_versions() {
        let index = create_test_index();
        let html = generate_html(&index);

        assert!(html.contains("2.0.0"));
        assert!(html.contains("1.0.0"));
    }

    #[test]
    fn test_generate_html_contains_install_command() {
        let index = create_test_index();
        let html = generate_html(&index);

        assert!(html.contains("pmp marketplace install aws-vpc"));
        assert!(html.contains("pmp marketplace install azure-vnet"));
    }

    #[test]
    fn test_generate_html_contains_tags() {
        let index = create_test_index();
        let html = generate_html(&index);

        assert!(html.contains("aws"));
        assert!(html.contains("azure"));
        assert!(html.contains("networking"));
    }

    #[test]
    fn test_write_index_files() {
        let fs = MockFileSystem::new();
        let output_dir = std::path::PathBuf::from("/output");
        let index = create_test_index();

        write_index_files(&fs, &output_dir, &index).unwrap();

        assert!(fs.has_file(&output_dir.join("index.json")));
        assert!(fs.has_file(&output_dir.join("index.html")));

        // Verify JSON content
        let json_content = fs.get_file_contents(&output_dir.join("index.json")).unwrap();
        let parsed: RegistryIndex = serde_json::from_str(&json_content).unwrap();
        assert_eq!(parsed.metadata.name, "test-registry");
        assert_eq!(parsed.packs.len(), 2);

        // Verify HTML content
        let html_content = fs.get_file_contents(&output_dir.join("index.html")).unwrap();
        assert!(html_content.contains("aws-vpc"));
    }

    #[test]
    fn test_generate_pack_card_minimal() {
        let pack = PackInfo::new("minimal-pack", "https://github.com/test/minimal");

        let card = generate_pack_card(&pack);

        assert!(card.contains("minimal-pack"));
        assert!(card.contains("No description available"));
        assert!(card.contains("No tags"));
    }
}
