use std::collections::{HashMap, HashSet};
use std::path::Path;

use crate::infrastructure::discovery::DiscoveredResource;
use crate::infrastructure::error::{ImportError, ImportResult};
use crate::infrastructure::resource_mapper::get_provider_info;

/// Configuration for generating import files
#[derive(Debug, Clone)]
pub struct GeneratorConfig {
    /// How to organize generated files
    pub file_organization: FileOrganization,
    /// Whether to add comments with resource details
    pub include_comments: bool,
    /// Custom name mappings (resource_id -> tf_name)
    pub name_overrides: HashMap<String, String>,
}

impl Default for GeneratorConfig {
    fn default() -> Self {
        Self {
            file_organization: FileOrganization::SingleFile,
            include_comments: true,
            name_overrides: HashMap::new(),
        }
    }
}

/// How to organize generated Terraform files
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FileOrganization {
    /// All resources in a single file (_imports.tf)
    SingleFile,
    /// One file per resource type (aws_vpc_imports.tf, aws_subnet_imports.tf)
    ByResourceType,
    /// One file per resource (vpc_main.tf, subnet_private.tf)
    ByResource,
}

/// Generates OpenTofu import configuration files
pub struct ConfigGenerator {
    config: GeneratorConfig,
}

impl ConfigGenerator {
    /// Create a new config generator
    pub fn new(config: GeneratorConfig) -> Self {
        Self { config }
    }

    /// Create with default config
    pub fn with_defaults() -> Self {
        Self::new(GeneratorConfig::default())
    }

    /// Generate import blocks for a list of resources
    pub fn generate_import_blocks(
        &self,
        resources: &[DiscoveredResource],
    ) -> ImportResult<String> {
        let mut output = String::new();

        if self.config.include_comments {
            output.push_str(
                "# Import blocks generated by PMP\n\
                 # Run: tofu plan -generate-config-out=generated_resources.tf\n\
                 # Then: tofu apply\n\n",
            );
        }

        for resource in resources {
            let tf_name = self.get_tf_name(resource);
            let block = self.generate_single_import_block(resource, &tf_name);
            output.push_str(&block);
            output.push('\n');
        }

        Ok(output)
    }

    /// Generate a single import block
    fn generate_single_import_block(
        &self,
        resource: &DiscoveredResource,
        tf_name: &str,
    ) -> String {
        let mut block = String::new();

        if self.config.include_comments {
            if let Some(name) = &resource.name {
                block.push_str(&format!("# {} - {}\n", resource.resource_type, name));
            }

            if let Some(region) = &resource.region {
                block.push_str(&format!("# Region: {}\n", region));
            }
        }

        block.push_str(&format!(
            "import {{\n  to = {}.{}\n  id = \"{}\"\n}}\n",
            resource.resource_type, tf_name, resource.resource_id
        ));

        block
    }

    /// Get the Terraform name for a resource
    fn get_tf_name(&self, resource: &DiscoveredResource) -> String {
        if let Some(name) = self.config.name_overrides.get(&resource.resource_id) {
            return name.clone();
        }

        resource.suggested_tf_name()
    }

    /// Generate files based on organization strategy
    pub fn generate_files(
        &self,
        resources: &[DiscoveredResource],
    ) -> ImportResult<HashMap<String, String>> {
        match self.config.file_organization {
            FileOrganization::SingleFile => {
                self.generate_single_file(resources)
            }
            FileOrganization::ByResourceType => {
                self.generate_by_resource_type(resources)
            }
            FileOrganization::ByResource => {
                self.generate_by_resource(resources)
            }
        }
    }

    fn generate_single_file(
        &self,
        resources: &[DiscoveredResource],
    ) -> ImportResult<HashMap<String, String>> {
        let content = self.generate_import_blocks(resources)?;
        let mut files = HashMap::new();
        files.insert("_imports.tf".to_string(), content);
        Ok(files)
    }

    fn generate_by_resource_type(
        &self,
        resources: &[DiscoveredResource],
    ) -> ImportResult<HashMap<String, String>> {
        let mut by_type: HashMap<String, Vec<&DiscoveredResource>> = HashMap::new();

        for resource in resources {
            by_type
                .entry(resource.resource_type.clone())
                .or_default()
                .push(resource);
        }

        let mut files = HashMap::new();

        for (resource_type, type_resources) in by_type {
            let filename = format!("{}_imports.tf", resource_type);
            let owned: Vec<DiscoveredResource> =
                type_resources.into_iter().cloned().collect();
            let content = self.generate_import_blocks(&owned)?;
            files.insert(filename, content);
        }

        Ok(files)
    }

    fn generate_by_resource(
        &self,
        resources: &[DiscoveredResource],
    ) -> ImportResult<HashMap<String, String>> {
        let mut files = HashMap::new();

        for resource in resources {
            let tf_name = self.get_tf_name(resource);
            let filename = format!("{}_{}.tf", resource.resource_type, tf_name);
            let content = self.generate_import_blocks(std::slice::from_ref(resource))?;
            files.insert(filename, content);
        }

        Ok(files)
    }

    /// Write generated files to a directory
    pub fn write_files(
        &self,
        resources: &[DiscoveredResource],
        output_dir: &Path,
    ) -> ImportResult<Vec<String>> {
        let files = self.generate_files(resources)?;
        let mut written = Vec::new();

        for (filename, content) in files {
            let path = output_dir.join(&filename);
            std::fs::write(&path, content).map_err(|e| {
                ImportError::FileSystem(format!(
                    "Failed to write {}: {}",
                    path.display(),
                    e
                ))
            })?;
            written.push(filename);
        }

        Ok(written)
    }
}

/// Generate provider configuration block
#[allow(dead_code)]
pub fn generate_provider_block(
    provider: &str,
    region: Option<&str>,
) -> String {
    match provider {
        "aws" => {
            if let Some(r) = region {
                format!(
                    "provider \"aws\" {{\n  region = \"{}\"\n}}\n",
                    r
                )
            } else {
                "provider \"aws\" {}\n".to_string()
            }
        }
        "azurerm" | "azure" => {
            "provider \"azurerm\" {\n  features {}\n}\n".to_string()
        }
        "google" | "gcp" => {
            if let Some(r) = region {
                format!(
                    "provider \"google\" {{\n  region = \"{}\"\n}}\n",
                    r
                )
            } else {
                "provider \"google\" {}\n".to_string()
            }
        }
        _ => format!("provider \"{}\" {{}}\n", provider),
    }
}

/// Generate terraform required_providers block (legacy - use generate_required_providers_from_resources)
#[allow(dead_code)]
pub fn generate_required_providers(providers: &[&str]) -> String {
    let mut block = String::from("terraform {\n  required_providers {\n");

    for provider in providers {
        let (source, version) = match *provider {
            "aws" => ("hashicorp/aws", "~> 5.0"),
            "azurerm" | "azure" => ("hashicorp/azurerm", "~> 3.0"),
            "google" | "gcp" => ("hashicorp/google", "~> 5.0"),
            _ => continue,
        };

        let name = if *provider == "azure" {
            "azurerm"
        } else if *provider == "gcp" {
            "google"
        } else {
            *provider
        };

        block.push_str(&format!(
            "    {} = {{\n      source  = \"{}\"\n      version = \"{}\"\n    }}\n",
            name, source, version
        ));
    }

    block.push_str("  }\n}\n");
    block
}

/// Result of generating required_providers block from resources
#[derive(Debug)]
#[allow(dead_code)]
pub struct RequiredProvidersResult {
    /// The generated HCL content for _providers.tf
    pub content: String,
    /// Providers that were included in the block
    pub included_providers: Vec<String>,
    /// Providers that have no known Terraform source (user must add manually)
    pub unsupported_providers: Vec<String>,
}

/// Generate required_providers block from discovered resources
///
/// Extracts unique providers from resources and generates the terraform
/// required_providers block with source and version constraints.
///
/// Returns the HCL content and lists of included/unsupported providers.
pub fn generate_required_providers_from_resources(
    resources: &[DiscoveredResource],
) -> RequiredProvidersResult {
    let mut seen_providers: HashSet<String> = HashSet::new();
    let mut included_providers: Vec<String> = Vec::new();
    let mut unsupported_providers: Vec<String> = Vec::new();

    // Extract unique providers from resources
    for resource in resources {
        let provider_name = resource.provider.to_string().to_lowercase();

        if seen_providers.contains(&provider_name) {
            continue;
        }
        seen_providers.insert(provider_name.clone());

        if let Some(info) = get_provider_info(&resource.provider) {
            included_providers.push(info.tf_name.to_string());
        } else {
            unsupported_providers.push(provider_name);
        }
    }

    // Sort for consistent output
    included_providers.sort();
    unsupported_providers.sort();

    // Generate the terraform block
    let mut content = String::new();
    content.push_str("# Required providers generated by PMP\n");
    content.push_str("# You may need to add provider configuration blocks below\n\n");
    content.push_str("terraform {\n  required_providers {\n");

    for tf_name in &included_providers {
        let provider = match tf_name.as_str() {
            "aws" => crate::infrastructure::discovery::Provider::Aws,
            "azurerm" => crate::infrastructure::discovery::Provider::Azure,
            "google" => crate::infrastructure::discovery::Provider::Gcp,
            "github" => crate::infrastructure::discovery::Provider::Github,
            "gitlab" => crate::infrastructure::discovery::Provider::Gitlab,
            "artifactory" => crate::infrastructure::discovery::Provider::Jfrog,
            "okta" => crate::infrastructure::discovery::Provider::Okta,
            "auth0" => crate::infrastructure::discovery::Provider::Auth0,
            "opsgenie" => crate::infrastructure::discovery::Provider::Opsgenie,
            _ => continue,
        };

        if let Some(info) = get_provider_info(&provider) {
            content.push_str(&format!(
                "    {} = {{\n      source  = \"{}\"\n      version = \"{}\"\n    }}\n",
                info.tf_name, info.source, info.default_version
            ));
        }
    }

    content.push_str("  }\n}\n");

    // Add provider configuration blocks
    content.push_str("\n# Provider configurations\n");
    content.push_str("# Configure these with your credentials and settings\n\n");

    for tf_name in &included_providers {
        let provider_block = generate_empty_provider_block(tf_name);
        content.push_str(&provider_block);
        content.push('\n');
    }

    // Add comments for unsupported providers
    if !unsupported_providers.is_empty() {
        content.push_str("# WARNING: The following providers have no known Terraform source.\n");
        content.push_str("# You must add them manually:\n");

        for provider in &unsupported_providers {
            content.push_str(&format!("#   - {}\n", provider));
        }
    }

    RequiredProvidersResult {
        content,
        included_providers,
        unsupported_providers,
    }
}

/// Generate an empty provider configuration block
fn generate_empty_provider_block(tf_name: &str) -> String {
    match tf_name {
        "aws" => {
            "provider \"aws\" {\n  # region = \"us-east-1\"\n}\n".to_string()
        }
        "azurerm" => {
            "provider \"azurerm\" {\n  features {}\n}\n".to_string()
        }
        "google" => {
            "provider \"google\" {\n  # project = \"your-project-id\"\n  # region  = \"us-central1\"\n}\n".to_string()
        }
        "github" => {
            "provider \"github\" {\n  # owner = \"your-org-or-user\"\n}\n".to_string()
        }
        "gitlab" => {
            "provider \"gitlab\" {\n  # base_url = \"https://gitlab.com/api/v4/\"\n}\n".to_string()
        }
        "artifactory" => {
            "provider \"artifactory\" {\n  # url = \"https://artifactory.example.com\"\n}\n".to_string()
        }
        "okta" => {
            "provider \"okta\" {\n  # org_name  = \"your-org\"\n  # base_url  = \"okta.com\"\n}\n".to_string()
        }
        "auth0" => {
            "provider \"auth0\" {\n  # domain = \"your-tenant.auth0.com\"\n}\n".to_string()
        }
        "opsgenie" => {
            "provider \"opsgenie\" {\n  # api_key = \"your-api-key\"\n}\n".to_string()
        }
        _ => format!("provider \"{}\" {{}}\n", tf_name),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::infrastructure::discovery::Provider;

    fn sample_resource() -> DiscoveredResource {
        DiscoveredResource::new(
            Provider::Aws,
            "aws_vpc".to_string(),
            "vpc-12345".to_string(),
        )
        .with_name("main-vpc")
        .with_region("us-east-1")
    }

    #[test]
    fn test_generate_import_block() {
        let generator = ConfigGenerator::with_defaults();
        let resources = vec![sample_resource()];
        let output = generator.generate_import_blocks(&resources).unwrap();

        assert!(output.contains("import {"));
        assert!(output.contains("to = aws_vpc.main_vpc"));
        assert!(output.contains("id = \"vpc-12345\""));
    }

    #[test]
    fn test_generate_import_block_without_comments() {
        let config = GeneratorConfig {
            include_comments: false,
            ..Default::default()
        };
        let generator = ConfigGenerator::new(config);
        let resources = vec![sample_resource()];
        let output = generator.generate_import_blocks(&resources).unwrap();

        assert!(!output.contains("# Import blocks"));
        assert!(output.contains("import {"));
    }

    #[test]
    fn test_generate_files_single() {
        let generator = ConfigGenerator::with_defaults();
        let resources = vec![sample_resource()];
        let files = generator.generate_files(&resources).unwrap();

        assert_eq!(files.len(), 1);
        assert!(files.contains_key("_imports.tf"));
    }

    #[test]
    fn test_generate_files_by_type() {
        let config = GeneratorConfig {
            file_organization: FileOrganization::ByResourceType,
            ..Default::default()
        };
        let generator = ConfigGenerator::new(config);

        let resources = vec![
            sample_resource(),
            DiscoveredResource::new(
                Provider::Aws,
                "aws_subnet".to_string(),
                "subnet-123".to_string(),
            ),
        ];

        let files = generator.generate_files(&resources).unwrap();

        assert_eq!(files.len(), 2);
        assert!(files.contains_key("aws_vpc_imports.tf"));
        assert!(files.contains_key("aws_subnet_imports.tf"));
    }

    #[test]
    fn test_generate_provider_block_aws() {
        let block = generate_provider_block("aws", Some("us-east-1"));
        assert!(block.contains("provider \"aws\""));
        assert!(block.contains("region = \"us-east-1\""));
    }

    #[test]
    fn test_generate_provider_block_azure() {
        let block = generate_provider_block("azurerm", None);
        assert!(block.contains("provider \"azurerm\""));
        assert!(block.contains("features {}"));
    }

    #[test]
    fn test_generate_required_providers() {
        let block = generate_required_providers(&["aws", "azurerm"]);

        assert!(block.contains("required_providers"));
        assert!(block.contains("hashicorp/aws"));
        assert!(block.contains("hashicorp/azurerm"));
    }

    #[test]
    fn test_generate_required_providers_from_resources_single_provider() {
        let resources = vec![
            DiscoveredResource::new(
                Provider::Aws,
                "aws_vpc".to_string(),
                "vpc-123".to_string(),
            ),
            DiscoveredResource::new(
                Provider::Aws,
                "aws_subnet".to_string(),
                "subnet-456".to_string(),
            ),
        ];

        let result = generate_required_providers_from_resources(&resources);

        assert!(result.content.contains("required_providers"));
        assert!(result.content.contains("hashicorp/aws"));
        assert!(result.content.contains("~> 5.0"));
        assert!(result.content.contains("provider \"aws\""));
        assert_eq!(result.included_providers, vec!["aws"]);
        assert!(result.unsupported_providers.is_empty());
    }

    #[test]
    fn test_generate_required_providers_from_resources_multiple_providers() {
        let resources = vec![
            DiscoveredResource::new(
                Provider::Aws,
                "aws_vpc".to_string(),
                "vpc-123".to_string(),
            ),
            DiscoveredResource::new(
                Provider::Github,
                "github_repository".to_string(),
                "my-repo".to_string(),
            ),
        ];

        let result = generate_required_providers_from_resources(&resources);

        assert!(result.content.contains("hashicorp/aws"));
        assert!(result.content.contains("integrations/github"));
        assert!(result.content.contains("provider \"aws\""));
        assert!(result.content.contains("provider \"github\""));
        assert_eq!(result.included_providers.len(), 2);
        assert!(result.included_providers.contains(&"aws".to_string()));
        assert!(result.included_providers.contains(&"github".to_string()));
    }

    #[test]
    fn test_generate_required_providers_from_resources_unsupported_provider() {
        let resources = vec![
            DiscoveredResource::new(
                Provider::Jira,
                "jira_project".to_string(),
                "PROJ".to_string(),
            ),
        ];

        let result = generate_required_providers_from_resources(&resources);

        assert!(result.included_providers.is_empty());
        assert_eq!(result.unsupported_providers, vec!["jira"]);
        assert!(result.content.contains("WARNING"));
        assert!(result.content.contains("jira"));
    }

    #[test]
    fn test_generate_required_providers_from_resources_mixed() {
        let resources = vec![
            DiscoveredResource::new(
                Provider::Aws,
                "aws_vpc".to_string(),
                "vpc-123".to_string(),
            ),
            DiscoveredResource::new(
                Provider::Jira,
                "jira_project".to_string(),
                "PROJ".to_string(),
            ),
        ];

        let result = generate_required_providers_from_resources(&resources);

        assert_eq!(result.included_providers, vec!["aws"]);
        assert_eq!(result.unsupported_providers, vec!["jira"]);
        assert!(result.content.contains("hashicorp/aws"));
        assert!(result.content.contains("WARNING"));
    }

    #[test]
    fn test_generate_empty_provider_block() {
        let aws_block = generate_empty_provider_block("aws");
        assert!(aws_block.contains("provider \"aws\""));
        assert!(aws_block.contains("# region"));

        let azure_block = generate_empty_provider_block("azurerm");
        assert!(azure_block.contains("provider \"azurerm\""));
        assert!(azure_block.contains("features {}"));

        let github_block = generate_empty_provider_block("github");
        assert!(github_block.contains("provider \"github\""));
        assert!(github_block.contains("# owner"));
    }
}
