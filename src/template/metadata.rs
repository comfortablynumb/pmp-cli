use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

// ============================================================================
// Template Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Template resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "Template")
    pub kind: String,

    /// Metadata about the template
    pub metadata: TemplateMetadata,

    /// Template specification
    pub spec: TemplateSpec,
}

/// Template metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateMetadata {
    /// Name of the template
    pub name: String,

    /// Description of what this template creates
    #[serde(default)]
    pub description: Option<String>,
}

/// Template specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateSpec {
    /// Categories this template belongs to
    pub categories: Vec<String>,

    /// Resource definition that this template generates
    pub resource: ResourceDefinition,

    /// Optional: Path to JSON Schema file (defaults to "schema.json")
    #[serde(default = "default_schema_path")]
    pub schema_path: String,

    /// Optional: Path to template source directory (defaults to "src")
    #[serde(default = "default_src_path")]
    pub src_path: String,

    /// Optional: Environment-specific configurations
    #[serde(default)]
    pub environments: Option<HashMap<String, EnvironmentConfig>>,
}

/// Defines the resource that will be generated by the template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceDefinition {
    /// API version of the generated resource (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of the generated resource (e.g., "Workload", "Infrastructure")
    pub kind: String,
}

fn default_schema_path() -> String {
    "schema.json".to_string()
}

fn default_src_path() -> String {
    "src".to_string()
}

/// Environment-specific configuration in template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentConfig {
    /// Description of this environment
    #[serde(default)]
    pub description: Option<String>,

    /// Schema property overrides for this environment
    #[serde(default)]
    pub overrides: HashMap<String, PropertyOverride>,
}

/// Override for a specific property in an environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PropertyOverride {
    /// Override the default value
    #[serde(default)]
    pub default: Option<Value>,

    /// Override the enum values (for string enums)
    #[serde(default)]
    pub enum_values: Option<Vec<String>>,

    /// Override the description
    #[serde(default)]
    pub description: Option<String>,
}

// ============================================================================
// Project Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Project resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Metadata about the project
    pub metadata: ProjectMetadata,

    /// Project specification
    pub spec: ProjectSpec,
}

/// Project metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectMetadata {
    /// Name of the project
    pub name: String,

    /// Description of this project
    #[serde(default)]
    pub description: Option<String>,
}

/// Project specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectSpec {
    /// Optional: IaC configuration
    #[serde(default)]
    pub iac: Option<IacProjectConfig>,

    /// Optional: Hooks configuration
    #[serde(default)]
    pub hooks: Option<HooksConfig>,
}

/// IaC configuration in project spec
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IacProjectConfig {
    /// Executor name (e.g., "opentofu", "terraform")
    #[serde(default = "default_executor")]
    pub executor: String,

    /// Optional: Custom commands
    #[serde(default)]
    pub commands: Option<IacCommands>,
}

fn default_executor() -> String {
    "opentofu".to_string()
}

/// Custom IaC commands
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IacCommands {
    /// Optional: Custom plan command
    pub plan: Option<String>,

    /// Optional: Custom apply command
    pub apply: Option<String>,
}

/// Hooks configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct HooksConfig {
    /// Commands to run before preview
    #[serde(default)]
    pub pre_preview: Vec<String>,

    /// Commands to run after preview
    #[serde(default)]
    pub post_preview: Vec<String>,

    /// Commands to run before apply
    #[serde(default)]
    pub pre_apply: Vec<String>,

    /// Commands to run after apply
    #[serde(default)]
    pub post_apply: Vec<String>,
}

// ============================================================================
// ProjectCollection Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style ProjectCollection resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "ProjectCollection")
    pub kind: String,

    /// Metadata about the project collection
    pub metadata: ProjectCollectionMetadata,

    /// ProjectCollection specification
    pub spec: ProjectCollectionSpec,
}

/// ProjectCollection metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionMetadata {
    /// Name of the project collection
    pub name: String,

    /// Description of this project collection
    #[serde(default)]
    pub description: Option<String>,
}

/// ProjectCollection specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionSpec {
    /// Whether to organize projects by category in folders
    #[serde(default)]
    pub organize_by_category: bool,

    /// Optional: Categories available in this collection
    #[serde(default)]
    pub categories: Option<std::collections::HashMap<String, Category>>,
}

/// Category definition in a ProjectCollection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Category {
    /// Display name of the category
    pub name: String,

    /// Optional: Description of the category
    #[serde(default)]
    pub description: Option<String>,

    /// Optional: Child categories (can be nested)
    #[serde(default)]
    pub children: Option<std::collections::HashMap<String, Category>>,
}

impl Category {
    /// Check if this category is a leaf (has no children)
    pub fn is_leaf(&self) -> bool {
        self.children.is_none() || self.children.as_ref().unwrap().is_empty()
    }

    /// Get all leaf category paths from this category (recursive)
    pub fn get_leaf_paths(&self, prefix: &str) -> Vec<String> {
        if self.is_leaf() {
            vec![prefix.to_string()]
        } else {
            let mut paths = Vec::new();
            if let Some(children) = &self.children {
                for (key, child) in children {
                    let child_prefix = if prefix.is_empty() {
                        key.clone()
                    } else {
                        format!("{}/{}", prefix, key)
                    };
                    paths.extend(child.get_leaf_paths(&child_prefix));
                }
            }
            paths
        }
    }
}

/// Reference to a project in the collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectReference {
    /// Name of the project
    pub name: String,

    /// Kind of the project (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Path to the project relative to the collection root
    pub path: String,

    /// Optional: Category of the project
    #[serde(default)]
    pub category: Option<String>,
}

// ============================================================================
// Implementation
// ============================================================================

impl TemplateResource {
    /// Load template resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: TemplateResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "Template" {
            anyhow::bail!("Expected kind 'Template', got '{}'", resource.kind);
        }

        Ok(resource)
    }

    /// Get the full path to the schema.json file
    pub fn schema_path(&self, base_path: &std::path::Path) -> std::path::PathBuf {
        base_path.join(&self.spec.schema_path)
    }

    /// Get the full path to the src directory
    pub fn src_path(&self, base_path: &std::path::Path) -> std::path::PathBuf {
        base_path.join(&self.spec.src_path)
    }
}

impl ProjectResource {
    /// Load project resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectResource = serde_yaml::from_str(&content)?;
        Ok(resource)
    }

    /// Get the IaC configuration, or return defaults
    pub fn get_iac_config(&self) -> IacProjectConfig {
        self.spec.iac.clone().unwrap_or_else(|| IacProjectConfig {
            executor: default_executor(),
            commands: None,
        })
    }

    /// Get the hooks configuration, or return empty hooks
    pub fn get_hooks(&self) -> HooksConfig {
        self.spec.hooks.clone().unwrap_or_default()
    }
}

impl ProjectCollectionResource {
    /// Load project collection resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectCollectionResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "ProjectCollection" {
            anyhow::bail!(
                "Expected kind 'ProjectCollection', got '{}'",
                resource.kind
            );
        }

        Ok(resource)
    }

    /// Save the collection to a .pmp.yaml file
    pub fn save(&self, path: &std::path::Path) -> anyhow::Result<()> {
        let content = serde_yaml::to_string(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }
}
