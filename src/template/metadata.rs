use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

// ============================================================================
// Template Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Template resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "Template")
    pub kind: String,

    /// Metadata about the template
    pub metadata: TemplateMetadata,

    /// Template specification
    pub spec: TemplateSpec,
}

/// Template metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateMetadata {
    /// Name of the template
    pub name: String,

    /// Description of what this template creates
    #[serde(default)]
    pub description: Option<String>,
}

/// Template specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateSpec {
    /// Resource definition that this template generates (REQUIRED)
    pub resource: ResourceDefinition,

    /// Input definitions for this template
    #[serde(default)]
    pub inputs: Vec<InputDefinition>,

    /// Optional: Path to template source directory (defaults to "src")
    #[serde(default = "default_src_path")]
    pub src_path: String,

    /// Optional: Custom fields for template-specific configuration
    #[serde(default)]
    pub custom: Option<HashMap<String, Value>>,
}

/// Defines the resource that will be generated by the template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceDefinition {
    /// API version of the generated resource (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of the generated resource (e.g., "Workload", "Infrastructure")
    pub kind: String,
}

fn default_src_path() -> String {
    "src".to_string()
}

/// Input definition for template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputDefinition {
    /// Name/key of the input
    pub name: String,

    /// Type of input
    #[serde(rename = "type")]
    pub input_type: InputType,

    /// Label/prompt to show user
    pub label: String,

    /// Optional: Help text to display
    #[serde(default)]
    pub help: Option<String>,

    /// Optional: Whether this input is required
    #[serde(default = "default_true")]
    pub required: bool,

    /// Optional: Default value
    #[serde(default)]
    pub default: Option<Value>,

    /// Optional: Options for select inputs
    #[serde(default)]
    pub options: Option<Vec<SelectOption>>,

    /// Optional: Validation rules
    #[serde(default)]
    pub validation: Option<InputValidation>,
}

fn default_true() -> bool {
    true
}

/// Type of input
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum InputType {
    /// Text input
    Text,
    /// Password input (hidden)
    Password,
    /// Boolean (true/false)
    Boolean,
    /// Single select from options
    Select,
    /// Multiple select from options
    MultiSelect,
}

/// Option for select/multiselect inputs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SelectOption {
    /// Value to use in template
    pub value: String,
    /// Label to display to user
    pub label: String,
}

/// Validation rules for inputs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputValidation {
    /// Minimum length for text inputs
    #[serde(default)]
    pub min_length: Option<usize>,

    /// Maximum length for text inputs
    #[serde(default)]
    pub max_length: Option<usize>,

    /// Regex pattern for text inputs
    #[serde(default)]
    pub pattern: Option<String>,

    /// Custom error message
    #[serde(default)]
    pub error_message: Option<String>,
}

// ============================================================================
// Project Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Project resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Metadata about the project
    pub metadata: ProjectMetadata,

    /// Project specification
    pub spec: ProjectSpec,
}

/// Project metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectMetadata {
    /// Name of the project
    pub name: String,

    /// Description of this project
    #[serde(default)]
    pub description: Option<String>,
}

/// Project specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectSpec {
    /// Optional: IaC configuration
    #[serde(default)]
    pub iac: Option<IacProjectConfig>,

    /// Optional: Hooks configuration
    #[serde(default)]
    pub hooks: Option<HooksConfig>,

    /// Optional: Additional categories for searching/filtering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub search_categories: Option<Vec<String>>,
}

/// IaC configuration in project spec
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IacProjectConfig {
    /// Executor name (e.g., "opentofu", "terraform")
    #[serde(default = "default_executor")]
    pub executor: String,

    /// Optional: Custom commands
    #[serde(default)]
    pub commands: Option<IacCommands>,
}

fn default_executor() -> String {
    "opentofu".to_string()
}

/// Custom IaC commands
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IacCommands {
    /// Optional: Custom plan command
    pub plan: Option<String>,

    /// Optional: Custom apply command
    pub apply: Option<String>,
}

/// Hooks configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct HooksConfig {
    /// Commands to run before preview
    #[serde(default)]
    pub pre_preview: Vec<String>,

    /// Commands to run after preview
    #[serde(default)]
    pub post_preview: Vec<String>,

    /// Commands to run before apply
    #[serde(default)]
    pub pre_apply: Vec<String>,

    /// Commands to run after apply
    #[serde(default)]
    pub post_apply: Vec<String>,
}

// ============================================================================
// ProjectCollection Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style ProjectCollection resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "ProjectCollection")
    pub kind: String,

    /// Metadata about the project collection
    pub metadata: ProjectCollectionMetadata,

    /// ProjectCollection specification
    pub spec: ProjectCollectionSpec,
}

/// ProjectCollection metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionMetadata {
    /// Name of the project collection
    pub name: String,

    /// Description of this project collection
    #[serde(default)]
    pub description: Option<String>,
}

/// ProjectCollection specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionSpec {
    /// Allowed resource kinds in this collection
    pub allowed_resources: Vec<ResourceKindFilter>,

    /// Available environments for projects in this collection
    pub environments: HashMap<String, Environment>,

    /// Whether to organize projects by category in folders
    #[serde(default)]
    pub organize_by_category: bool,

    /// Optional: Categories available in this collection
    #[serde(default)]
    pub categories: Option<std::collections::HashMap<String, Category>>,
}

/// Filter for allowed resource kinds
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceKindFilter {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind (e.g., "Workload", "Infrastructure")
    pub kind: String,
}

impl ResourceKindFilter {
    /// Check if this filter matches a resource definition
    pub fn matches(&self, resource: &ResourceDefinition) -> bool {
        self.api_version == resource.api_version && self.kind == resource.kind
    }
}

/// Environment definition in ProjectCollection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Environment {
    /// Display name
    pub name: String,

    /// Optional: Description
    #[serde(default)]
    pub description: Option<String>,
}

/// Category definition in a ProjectCollection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Category {
    /// Display name of the category
    pub name: String,

    /// Optional: Description of the category
    #[serde(default)]
    pub description: Option<String>,

    /// Resource kinds allowed in this category
    #[serde(default)]
    pub resource_kinds: Vec<ResourceKindFilter>,

    /// Optional: Child categories (can be nested)
    #[serde(default)]
    pub children: Option<std::collections::HashMap<String, Category>>,
}

impl Category {
    /// Check if this category is a leaf (has no children)
    pub fn is_leaf(&self) -> bool {
        self.children.is_none() || self.children.as_ref().unwrap().is_empty()
    }

    /// Get all leaf category paths from this category (recursive)
    pub fn get_leaf_paths(&self, prefix: &str) -> Vec<String> {
        if self.is_leaf() {
            vec![prefix.to_string()]
        } else {
            let mut paths = Vec::new();
            if let Some(children) = &self.children {
                for (key, child) in children {
                    let child_prefix = if prefix.is_empty() {
                        key.clone()
                    } else {
                        format!("{}/{}", prefix, key)
                    };
                    paths.extend(child.get_leaf_paths(&child_prefix));
                }
            }
            paths
        }
    }
}

/// Reference to a project in the collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectReference {
    /// Name of the project
    pub name: String,

    /// Kind of the project (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Path to the project relative to the collection root
    pub path: String,

    /// Optional: Category of the project (primary category for organization)
    #[serde(default)]
    pub category: Option<String>,

    /// Optional: Additional categories for searching/filtering
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub search_categories: Option<Vec<String>>,
}

// ============================================================================
// Implementation
// ============================================================================

impl TemplateResource {
    /// Load template resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: TemplateResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "Template" {
            anyhow::bail!("Expected kind 'Template', got '{}'", resource.kind);
        }

        // Validate resource kind contains only alphanumeric characters
        let resource_kind = &resource.spec.resource.kind;
        if !resource_kind.chars().all(|c| c.is_alphanumeric()) {
            anyhow::bail!(
                "Resource kind '{}' must contain only alphanumeric characters",
                resource_kind
            );
        }

        Ok(resource)
    }

    /// Get the full path to the src directory
    pub fn src_path(&self, base_path: &std::path::Path) -> std::path::PathBuf {
        base_path.join(&self.spec.src_path)
    }
}

impl ProjectResource {
    /// Load project resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectResource = serde_yaml::from_str(&content)?;
        Ok(resource)
    }

    /// Get the IaC configuration, or return defaults
    pub fn get_iac_config(&self) -> IacProjectConfig {
        self.spec.iac.clone().unwrap_or_else(|| IacProjectConfig {
            executor: default_executor(),
            commands: None,
        })
    }

    /// Get the hooks configuration, or return empty hooks
    pub fn get_hooks(&self) -> HooksConfig {
        self.spec.hooks.clone().unwrap_or_default()
    }
}

impl ProjectCollectionResource {
    /// Load project collection resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectCollectionResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "ProjectCollection" {
            anyhow::bail!(
                "Expected kind 'ProjectCollection', got '{}'",
                resource.kind
            );
        }

        Ok(resource)
    }

    /// Save the collection to a .pmp.yaml file
    pub fn save(&self, path: &std::path::Path) -> anyhow::Result<()> {
        let content = serde_yaml::to_string(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }
}
