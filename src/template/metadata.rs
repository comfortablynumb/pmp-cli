use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

// ============================================================================
// Template Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Template resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "Template")
    pub kind: String,

    /// Metadata about the template
    pub metadata: TemplateMetadata,

    /// Template specification
    pub spec: TemplateSpec,
}

/// Template metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateMetadata {
    /// Name of the template
    pub name: String,

    /// Description of what this template creates
    #[serde(default)]
    pub description: Option<String>,
}

/// Template specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateSpec {
    /// Resource definition that this template generates (REQUIRED)
    pub resource: ResourceSpec,

    /// Optional: Path to template source directory (defaults to "src")
    #[serde(default = "default_src_path")]
    pub src_path: String,

    /// Optional: Custom fields for template-specific configuration
    #[serde(default)]
    pub custom: Option<HashMap<String, Value>>,
}

/// Resource specification in template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceSpec {
    /// API version of the generated resource (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of the generated resource (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Executor name (e.g., "opentofu", "terraform") (REQUIRED)
    pub executor: String,

    /// Inputs applied to all environments
    #[serde(default)]
    pub inputs: HashMap<String, InputSpec>,

    /// Environment-specific overrides
    #[serde(default)]
    pub environments: HashMap<String, EnvironmentOverrides>,
}

/// Defines the resource that will be generated by the template (simplified)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceDefinition {
    /// API version of the generated resource (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of the generated resource (e.g., "Workload", "Infrastructure")
    pub kind: String,
}

/// Input specification for a template input
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputSpec {
    /// Possible enum values for this input
    #[serde(default)]
    pub enum_values: Option<Vec<String>>,

    /// Default value
    #[serde(default)]
    pub default: Option<Value>,

    /// Description of the input
    #[serde(default)]
    pub description: Option<String>,
}

/// Environment-specific overrides
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentOverrides {
    /// Override inputs for this environment
    #[serde(default)]
    pub overrides: OverridesSpec,
}

/// Overrides specification
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct OverridesSpec {
    /// Input overrides
    #[serde(default)]
    pub inputs: HashMap<String, InputSpec>,
}

fn default_src_path() -> String {
    "src".to_string()
}

// ============================================================================
// Project Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Project resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Metadata about the project
    pub metadata: ProjectMetadata,

    /// Project specification
    pub spec: ProjectSpec,
}

/// Project metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectMetadata {
    /// Name of the project
    pub name: String,

    /// Description of this project
    #[serde(default)]
    pub description: Option<String>,
}

/// Project specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectSpec {
    /// Resource definition that this project implements (REQUIRED)
    pub resource: ResourceDefinition,

    /// Executor configuration (executor/provider)
    pub executor: ExecutorProjectConfig,

    /// User inputs collected during project creation
    pub inputs: HashMap<String, Value>,

    /// Optional: Custom fields from template
    #[serde(default)]
    pub custom: Option<HashMap<String, Value>>,
}

/// Executor configuration in project spec
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutorProjectConfig {
    /// Executor name (e.g., "opentofu", "terraform")
    pub name: String,
}


// ============================================================================
// ProjectCollection Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style ProjectCollection resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "ProjectCollection")
    pub kind: String,

    /// Metadata about the project collection
    pub metadata: ProjectCollectionMetadata,

    /// ProjectCollection specification
    pub spec: ProjectCollectionSpec,
}

/// ProjectCollection metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionMetadata {
    /// Name of the project collection
    pub name: String,

    /// Description of this project collection
    #[serde(default)]
    pub description: Option<String>,
}

/// ProjectCollection specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionSpec {
    /// Allowed resource kinds in this collection
    #[serde(default)]
    pub resource_kinds: Vec<ResourceKindFilter>,

    /// Available environments for projects in this collection
    pub environments: HashMap<String, Environment>,

    /// Optional: Hooks configuration for all projects in this collection
    #[serde(default)]
    pub hooks: Option<HooksConfig>,
}

/// Hooks configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct HooksConfig {
    /// Commands to run before preview
    #[serde(default)]
    pub pre_preview: Vec<String>,

    /// Commands to run after preview
    #[serde(default)]
    pub post_preview: Vec<String>,

    /// Commands to run before apply
    #[serde(default)]
    pub pre_apply: Vec<String>,

    /// Commands to run after apply
    #[serde(default)]
    pub post_apply: Vec<String>,
}

/// Filter for allowed resource kinds
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceKindFilter {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind (e.g., "Workload", "Infrastructure")
    pub kind: String,
}

impl ResourceKindFilter {
    /// Check if this filter matches a resource definition
    #[allow(dead_code)]
    pub fn matches(&self, resource: &ResourceDefinition) -> bool {
        self.api_version == resource.api_version && self.kind == resource.kind
    }

    /// Check if this filter matches a resource spec
    pub fn matches_spec(&self, resource: &ResourceSpec) -> bool {
        self.api_version == resource.api_version && self.kind == resource.kind
    }
}

impl ResourceSpec {
    /// Convert to a simplified ResourceDefinition
    #[allow(dead_code)]
    pub fn to_definition(&self) -> ResourceDefinition {
        ResourceDefinition {
            api_version: self.api_version.clone(),
            kind: self.kind.clone(),
        }
    }
}

/// Environment definition in ProjectCollection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Environment {
    /// Display name
    pub name: String,

    /// Optional: Description
    #[serde(default)]
    pub description: Option<String>,
}

/// Reference to a project in the collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectReference {
    /// Name of the project
    pub name: String,

    /// Kind of the project (e.g., "KubernetesWorkload", "Infrastructure")
    pub kind: String,

    /// Path to the project relative to the collection root
    pub path: String,
}

// ============================================================================
// Implementation
// ============================================================================

impl TemplateResource {
    /// Load template resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: TemplateResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "Template" {
            anyhow::bail!("Expected kind 'Template', got '{}'", resource.kind);
        }

        // Validate resource kind contains only alphanumeric characters
        let resource_kind = &resource.spec.resource.kind;
        if !resource_kind.chars().all(|c| c.is_alphanumeric()) {
            anyhow::bail!(
                "Resource kind '{}' must contain only alphanumeric characters",
                resource_kind
            );
        }

        Ok(resource)
    }

    /// Get the full path to the src directory
    pub fn src_path(&self, base_path: &std::path::Path) -> std::path::PathBuf {
        base_path.join(&self.spec.src_path)
    }
}

impl ProjectResource {
    /// Load project resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectResource = serde_yaml::from_str(&content)?;
        Ok(resource)
    }

    /// Get the executor configuration
    pub fn get_executor_config(&self) -> &ExecutorProjectConfig {
        &self.spec.executor
    }
}

impl ProjectCollectionResource {
    /// Load project collection resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectCollectionResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "ProjectCollection" {
            anyhow::bail!(
                "Expected kind 'ProjectCollection', got '{}'",
                resource.kind
            );
        }

        Ok(resource)
    }

    /// Save the collection to a .pmp.yaml file
    pub fn save(&self, path: &std::path::Path) -> anyhow::Result<()> {
        let content = serde_yaml::to_string(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Get the hooks configuration, or return empty hooks
    pub fn get_hooks(&self) -> HooksConfig {
        self.spec.hooks.clone().unwrap_or_default()
    }
}
