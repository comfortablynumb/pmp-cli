use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

// ============================================================================
// Template Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Template resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "Template")
    pub kind: String,

    /// Metadata about the template
    pub metadata: TemplateMetadata,

    /// Template specification
    pub spec: TemplateSpec,
}

/// Template metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateMetadata {
    /// Name of the template
    pub name: String,

    /// Description of what this template creates
    #[serde(default)]
    pub description: Option<String>,
}

/// Template specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateSpec {
    /// Categories this template belongs to
    pub categories: Vec<String>,

    /// Resource definition that this template generates
    pub resource: ResourceDefinition,

    /// Optional: Path to JSON Schema file (defaults to "schema.json")
    #[serde(default = "default_schema_path")]
    pub schema_path: String,

    /// Optional: Path to template source directory (defaults to "src")
    #[serde(default = "default_src_path")]
    pub src_path: String,

    /// Optional: Environment-specific configurations
    #[serde(default)]
    pub environments: Option<HashMap<String, EnvironmentConfig>>,
}

/// Defines the resource that will be generated by the template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceDefinition {
    /// API version of the generated resource (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of the generated resource (e.g., "Workload", "Infrastructure")
    pub kind: String,
}

fn default_schema_path() -> String {
    "schema.json".to_string()
}

fn default_src_path() -> String {
    "src".to_string()
}

/// Environment-specific configuration in template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentConfig {
    /// Description of this environment
    #[serde(default)]
    pub description: Option<String>,

    /// Schema property overrides for this environment
    #[serde(default)]
    pub overrides: HashMap<String, PropertyOverride>,
}

/// Override for a specific property in an environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PropertyOverride {
    /// Override the default value
    #[serde(default)]
    pub default: Option<Value>,

    /// Override the enum values (for string enums)
    #[serde(default)]
    pub enum_values: Option<Vec<String>>,

    /// Override the description
    #[serde(default)]
    pub description: Option<String>,
}

// ============================================================================
// Project Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style Project resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Metadata about the project
    pub metadata: ProjectMetadata,

    /// Project specification
    pub spec: ProjectSpec,
}

/// Project metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectMetadata {
    /// Name of the project
    pub name: String,

    /// Description of this project
    #[serde(default)]
    pub description: Option<String>,
}

/// Project specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectSpec {
    /// Optional: IaC configuration
    #[serde(default)]
    pub iac: Option<IacProjectConfig>,

    /// Optional: Hooks configuration
    #[serde(default)]
    pub hooks: Option<HooksConfig>,
}

/// IaC configuration in project spec
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IacProjectConfig {
    /// Executor name (e.g., "opentofu", "terraform")
    #[serde(default = "default_executor")]
    pub executor: String,

    /// Optional: Custom commands
    #[serde(default)]
    pub commands: Option<IacCommands>,
}

fn default_executor() -> String {
    "opentofu".to_string()
}

/// Custom IaC commands
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IacCommands {
    /// Optional: Custom plan command
    pub plan: Option<String>,

    /// Optional: Custom apply command
    pub apply: Option<String>,
}

/// Hooks configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct HooksConfig {
    /// Commands to run before preview
    #[serde(default)]
    pub pre_preview: Vec<String>,

    /// Commands to run after preview
    #[serde(default)]
    pub post_preview: Vec<String>,

    /// Commands to run before apply
    #[serde(default)]
    pub pre_apply: Vec<String>,

    /// Commands to run after apply
    #[serde(default)]
    pub post_apply: Vec<String>,
}

// ============================================================================
// ProjectCollection Resource (Kubernetes-style)
// ============================================================================

/// Kubernetes-style ProjectCollection resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionResource {
    /// API version (e.g., "pmp.io/v1")
    #[serde(rename = "apiVersion")]
    pub api_version: String,

    /// Kind of resource (always "ProjectCollection")
    pub kind: String,

    /// Metadata about the project collection
    pub metadata: ProjectCollectionMetadata,

    /// ProjectCollection specification
    pub spec: ProjectCollectionSpec,
}

/// ProjectCollection metadata (Kubernetes-style)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionMetadata {
    /// Name of the project collection
    pub name: String,

    /// Description of this project collection
    #[serde(default)]
    pub description: Option<String>,
}

/// ProjectCollection specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectCollectionSpec {
    /// Projects in this collection
    #[serde(default)]
    pub projects: Vec<ProjectReference>,

    /// Whether to organize projects by category in folders
    #[serde(default)]
    pub organize_by_category: bool,
}

/// Reference to a project in the collection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectReference {
    /// Name of the project
    pub name: String,

    /// Kind of the project (e.g., "Workload", "Infrastructure")
    pub kind: String,

    /// Path to the project relative to the collection root
    pub path: String,

    /// Optional: Category of the project
    #[serde(default)]
    pub category: Option<String>,
}

// ============================================================================
// Implementation
// ============================================================================

impl TemplateResource {
    /// Load template resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: TemplateResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "Template" {
            anyhow::bail!("Expected kind 'Template', got '{}'", resource.kind);
        }

        Ok(resource)
    }

    /// Get the full path to the schema.json file
    pub fn schema_path(&self, base_path: &std::path::Path) -> std::path::PathBuf {
        base_path.join(&self.spec.schema_path)
    }

    /// Get the full path to the src directory
    pub fn src_path(&self, base_path: &std::path::Path) -> std::path::PathBuf {
        base_path.join(&self.spec.src_path)
    }
}

impl ProjectResource {
    /// Load project resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectResource = serde_yaml::from_str(&content)?;
        Ok(resource)
    }

    /// Get the IaC configuration, or return defaults
    pub fn get_iac_config(&self) -> IacProjectConfig {
        self.spec.iac.clone().unwrap_or_else(|| IacProjectConfig {
            executor: default_executor(),
            commands: None,
        })
    }

    /// Get the hooks configuration, or return empty hooks
    pub fn get_hooks(&self) -> HooksConfig {
        self.spec.hooks.clone().unwrap_or_default()
    }
}

impl ProjectCollectionResource {
    /// Load project collection resource from a .pmp.yaml file
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let resource: ProjectCollectionResource = serde_yaml::from_str(&content)?;

        // Validate kind
        if resource.kind != "ProjectCollection" {
            anyhow::bail!(
                "Expected kind 'ProjectCollection', got '{}'",
                resource.kind
            );
        }

        Ok(resource)
    }

    /// Add a project to the collection
    pub fn add_project(&mut self, project: ProjectReference) {
        self.spec.projects.push(project);
    }

    /// Remove a project from the collection by name and kind
    #[allow(dead_code)]
    pub fn remove_project(&mut self, name: &str, kind: &str) -> bool {
        if let Some(pos) = self
            .spec
            .projects
            .iter()
            .position(|p| p.name == name && p.kind == kind)
        {
            self.spec.projects.remove(pos);
            true
        } else {
            false
        }
    }

    /// Check if a project with the same name and kind already exists
    pub fn has_project(&self, name: &str, kind: &str) -> bool {
        self.spec
            .projects
            .iter()
            .any(|p| p.name == name && p.kind == kind)
    }

    /// Find projects by name (case-insensitive)
    pub fn find_by_name(&self, name: &str) -> Vec<&ProjectReference> {
        let name_lower = name.to_lowercase();
        self.spec
            .projects
            .iter()
            .filter(|p| p.name.to_lowercase().contains(&name_lower))
            .collect()
    }

    /// Find projects by category
    pub fn find_by_category(&self, category: &str) -> Vec<&ProjectReference> {
        self.spec
            .projects
            .iter()
            .filter(|p| {
                p.category
                    .as_ref()
                    .map(|c| c.eq_ignore_ascii_case(category))
                    .unwrap_or(false)
            })
            .collect()
    }

    /// Find projects by kind
    pub fn find_by_kind(&self, kind: &str) -> Vec<&ProjectReference> {
        self.spec
            .projects
            .iter()
            .filter(|p| p.kind.eq_ignore_ascii_case(kind))
            .collect()
    }

    /// Save the collection to a .pmp.yaml file
    pub fn save(&self, path: &std::path::Path) -> anyhow::Result<()> {
        let content = serde_yaml::to_string(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }
}
