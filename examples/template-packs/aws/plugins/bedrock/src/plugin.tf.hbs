terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

locals {
  resource_name = var.project_name

  # Parse lists
  pii_entities_list = var.pii_entities_to_block != "" ? split(",", var.pii_entities_to_block) : []
  blocked_topics_list = var.blocked_topics != "" ? split(",", var.blocked_topics) : []

  # OpenSearch collection name
  opensearch_collection = var.opensearch_collection_name != "" ? var.opensearch_collection_name : "${local.resource_name}-vectors"

  # Tags
  common_tags = merge(
    {
      Name      = var.project_name
      ManagedBy = "pmp"
      Plugin    = "aws/bedrock"
    },
    var.environment != "" ? { Environment = var.environment } : {},
    var.application != "" ? { Application = var.application } : {}
  )
}

{{#if enable_cloudwatch_logs}}
# CloudWatch Log Group for Bedrock
resource "aws_cloudwatch_log_group" "plugin_bedrock" {
  name              = "/aws/bedrock/${local.resource_name}"
  retention_in_days = var.log_retention_days

  tags = local.common_tags
}
{{/if}}

{{#if (eq resource_type "knowledge-base")}}
# IAM role for Bedrock Knowledge Base
resource "aws_iam_role" "plugin_bedrock_kb" {
  name = "${local.resource_name}-kb-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "bedrock.amazonaws.com"
        }
        Action = "sts:AssumeRole"
        Condition = {
          StringEquals = {
            "aws:SourceAccount" = data.aws_caller_identity.current.account_id
          }
          ArnLike = {
            "aws:SourceArn" = "arn:aws:bedrock:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:knowledge-base/*"
          }
        }
      }
    ]
  })

  tags = local.common_tags
}

# Policy for Knowledge Base to access S3
resource "aws_iam_role_policy" "plugin_bedrock_kb_s3" {
  name = "${local.resource_name}-kb-s3-policy"
  role = aws_iam_role.plugin_bedrock_kb.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:ListBucket"
        ]
        Resource = [
          "arn:aws:s3:::${var.kb_s3_bucket_name}",
          "arn:aws:s3:::${var.kb_s3_bucket_name}/*"
        ]
      }
    ]
  })
}

# Policy for Knowledge Base to invoke embedding model
resource "aws_iam_role_policy" "plugin_bedrock_kb_model" {
  name = "${local.resource_name}-kb-model-policy"
  role = aws_iam_role.plugin_bedrock_kb.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "bedrock:InvokeModel"
        ]
        Resource = [
          "arn:aws:bedrock:${data.aws_region.current.name}::foundation-model/${var.kb_embedding_model}"
        ]
      }
    ]
  })
}

{{#if (eq vector_store_type "opensearch-serverless")}}
# OpenSearch Serverless collection for vector storage
resource "aws_opensearchserverless_collection" "plugin_bedrock" {
  name = local.opensearch_collection
  type = "VECTORSEARCH"

  tags = local.common_tags
}

# OpenSearch Serverless security policy
resource "aws_opensearchserverless_security_policy" "plugin_bedrock_encryption" {
  name = "${local.opensearch_collection}-encryption"
  type = "encryption"

  policy = jsonencode({
    Rules = [
      {
        ResourceType = "collection"
        Resource = ["collection/${local.opensearch_collection}"]
      }
    ]
    AWSOwnedKey = true
  })
}

resource "aws_opensearchserverless_security_policy" "plugin_bedrock_network" {
  name = "${local.opensearch_collection}-network"
  type = "network"

  policy = jsonencode([
    {
      Rules = [
        {
          ResourceType = "collection"
          Resource = ["collection/${local.opensearch_collection}"]
        }
      ]
      AllowFromPublic = true
    }
  ])
}

# Data access policy for Bedrock to access OpenSearch
resource "aws_opensearchserverless_access_policy" "plugin_bedrock" {
  name = "${local.opensearch_collection}-access"
  type = "data"

  policy = jsonencode([
    {
      Rules = [
        {
          ResourceType = "collection"
          Resource = ["collection/${local.opensearch_collection}"]
          Permission = [
            "aoss:CreateCollectionItems",
            "aoss:UpdateCollectionItems",
            "aoss:DescribeCollectionItems"
          ]
        },
        {
          ResourceType = "index"
          Resource = ["index/${local.opensearch_collection}/*"]
          Permission = [
            "aoss:CreateIndex",
            "aoss:DescribeIndex",
            "aoss:ReadDocument",
            "aoss:WriteDocument",
            "aoss:UpdateIndex",
            "aoss:DeleteIndex"
          ]
        }
      ]
      Principal = [
        aws_iam_role.plugin_bedrock_kb.arn
      ]
    }
  ])
}

# IAM policy for Knowledge Base to access OpenSearch
resource "aws_iam_role_policy" "plugin_bedrock_kb_opensearch" {
  name = "${local.resource_name}-kb-opensearch-policy"
  role = aws_iam_role.plugin_bedrock_kb.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "aoss:APIAccessAll"
        ]
        Resource = [
          aws_opensearchserverless_collection.plugin_bedrock.arn
        ]
      }
    ]
  })
}
{{/if}}

# Bedrock Knowledge Base
resource "aws_bedrockagent_knowledge_base" "plugin_bedrock" {
  name     = local.resource_name
  role_arn = aws_iam_role.plugin_bedrock_kb.arn

  knowledge_base_configuration {
    vector_knowledge_base_configuration {
      embedding_model_arn = "arn:aws:bedrock:${data.aws_region.current.name}::foundation-model/${var.kb_embedding_model}"
    }
    type = "VECTOR"
  }

  storage_configuration {
    {{#if (eq vector_store_type "opensearch-serverless")}}
    type = "OPENSEARCH_SERVERLESS"
    opensearch_serverless_configuration {
      collection_arn    = aws_opensearchserverless_collection.plugin_bedrock.arn
      vector_index_name = var.opensearch_index_name

      field_mapping {
        vector_field   = "embedding"
        text_field     = "text"
        metadata_field = "metadata"
      }
    }
    {{/if}}
  }

  tags = local.common_tags

  depends_on = [
    aws_iam_role_policy.plugin_bedrock_kb_s3,
    aws_iam_role_policy.plugin_bedrock_kb_model,
    {{#if (eq vector_store_type "opensearch-serverless")}}
    aws_iam_role_policy.plugin_bedrock_kb_opensearch,
    aws_opensearchserverless_access_policy.plugin_bedrock
    {{/if}}
  ]
}

# Data Source for Knowledge Base
resource "aws_bedrockagent_data_source" "plugin_bedrock" {
  knowledge_base_id = aws_bedrockagent_knowledge_base.plugin_bedrock.id
  name              = "${local.resource_name}-datasource"

  data_source_configuration {
    type = "S3"
    s3_configuration {
      bucket_arn = "arn:aws:s3:::${var.kb_s3_bucket_name}"
      {{#if kb_s3_prefix}}
      inclusion_prefixes = [var.kb_s3_prefix]
      {{/if}}
    }
  }
}

{{else if (eq resource_type "agent")}}
# IAM role for Bedrock Agent
resource "aws_iam_role" "plugin_bedrock_agent" {
  name = "${local.resource_name}-agent-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "bedrock.amazonaws.com"
        }
        Action = "sts:AssumeRole"
        Condition = {
          StringEquals = {
            "aws:SourceAccount" = data.aws_caller_identity.current.account_id
          }
          ArnLike = {
            "aws:SourceArn" = "arn:aws:bedrock:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:agent/*"
          }
        }
      }
    ]
  })

  tags = local.common_tags
}

# Policy for Agent to invoke foundation model
resource "aws_iam_role_policy" "plugin_bedrock_agent_model" {
  name = "${local.resource_name}-agent-model-policy"
  role = aws_iam_role.plugin_bedrock_agent.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "bedrock:InvokeModel"
        ]
        Resource = [
          "arn:aws:bedrock:${data.aws_region.current.name}::foundation-model/${var.foundation_model}"
        ]
      }
    ]
  })
}

# Bedrock Agent
resource "aws_bedrockagent_agent" "plugin_bedrock" {
  agent_name              = local.resource_name
  agent_resource_role_arn = aws_iam_role.plugin_bedrock_agent.arn
  foundation_model        = var.foundation_model
  instruction             = var.agent_instruction
  idle_session_ttl_in_seconds = var.agent_idle_session_ttl

  tags = local.common_tags

  depends_on = [
    aws_iam_role_policy.plugin_bedrock_agent_model
  ]
}

{{else if (eq resource_type "guardrails")}}
# Bedrock Guardrails
resource "aws_bedrock_guardrail" "plugin_bedrock" {
  name                      = local.resource_name
  blocked_input_messaging   = var.guardrail_blocked_messaging
  blocked_outputs_messaging = var.guardrail_blocked_messaging

  {{#if enable_content_filters}}
  content_policy_config {
    filters_config {
      type = "HATE"
      input_strength = var.content_filter_strength
      output_strength = var.content_filter_strength
    }
    filters_config {
      type = "VIOLENCE"
      input_strength = var.content_filter_strength
      output_strength = var.content_filter_strength
    }
    filters_config {
      type = "SEXUAL"
      input_strength = var.content_filter_strength
      output_strength = var.content_filter_strength
    }
    filters_config {
      type = "MISCONDUCT"
      input_strength = var.content_filter_strength
      output_strength = var.content_filter_strength
    }
  }
  {{/if}}

  {{#if enable_pii_detection}}
  sensitive_information_policy_config {
    {{#each pii_entities_list}}
    pii_entities_config {
      type   = "{{this}}"
      action = "BLOCK"
    }
    {{/each}}
  }
  {{/if}}

  {{#if enable_topic_filters}}
  topic_policy_config {
    {{#each blocked_topics_list}}
    topics_config {
      name       = "{{this}}"
      definition = "Content related to {{this}}"
      type       = "DENY"
    }
    {{/each}}
  }
  {{/if}}

  tags = local.common_tags
}
{{/if}}
