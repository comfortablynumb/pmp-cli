output "postgres_service_name" {
  description = "Name of the PostgreSQL service"
  value       = helm_release.postgres.name
}

output "postgres_namespace" {
  description = "Namespace where PostgreSQL is deployed"
  value       = helm_release.postgres.namespace
}

output "postgres_database_name" {
  description = "Name of the PostgreSQL database"
  value       = var.database_name
}

output "postgres_username" {
  description = "PostgreSQL username"
  value       = var.postgres_username
}

output "postgres_password" {
  description = "PostgreSQL password"
  value       = var.postgres_password
  sensitive   = true
}

output "postgres_port" {
  description = "PostgreSQL port"
  value       = 5432
}

output "postgres_sslmode" {
  description = "PostgreSQL SSL mode"
  value       = var.sslmode
}

output "postgres_service_url" {
  description = "Internal PostgreSQL service URL"
  value       = "postgresql://${helm_release.postgres.name}.${helm_release.postgres.namespace}.svc.cluster.local:5432/${var.database_name}"
}

# Data source to fetch LoadBalancer IP when service_type is LoadBalancer
{{#if (eq service_type "LoadBalancer")}}
data "kubernetes_service" "postgres" {
  metadata {
    name      = "${helm_release.postgres.name}-postgresql"
    namespace = helm_release.postgres.namespace
  }
  depends_on = [helm_release.postgres]
}
{{/if}}

output "postgres_host" {
  description = "PostgreSQL service hostname (external for LoadBalancer, internal for ClusterIP/NodePort)"
  value       = {{#if (eq service_type "LoadBalancer")}}try(
    coalesce(
      try(data.kubernetes_service.postgres.status[0].load_balancer[0].ingress[0].hostname, null),
      try(data.kubernetes_service.postgres.status[0].load_balancer[0].ingress[0].ip, null),
      "${helm_release.postgres.name}.${helm_release.postgres.namespace}.svc.cluster.local"
    ),
    "${helm_release.postgres.name}.${helm_release.postgres.namespace}.svc.cluster.local"
  ){{else}}"${helm_release.postgres.name}.${helm_release.postgres.namespace}.svc.cluster.local"{{/if}}
}

{{#if (eq service_type "LoadBalancer")}}
output "postgres_external_host" {
  description = "PostgreSQL LoadBalancer external hostname or IP"
  value       = try(
    coalesce(
      try(data.kubernetes_service.postgres.status[0].load_balancer[0].ingress[0].hostname, null),
      try(data.kubernetes_service.postgres.status[0].load_balancer[0].ingress[0].ip, null),
      "pending"
    ),
    "pending"
  )
}

output "postgres_loadbalancer_status" {
  description = "LoadBalancer status and connection info"
  value = <<-EOT
    LoadBalancer Service: ${helm_release.postgres.name}-postgresql
    External Hostname/IP: ${try(
      coalesce(
        try(data.kubernetes_service.postgres.status[0].load_balancer[0].ingress[0].hostname, null),
        try(data.kubernetes_service.postgres.status[0].load_balancer[0].ingress[0].ip, null),
        "pending (waiting for cloud provider to assign)"
      ),
      "pending (waiting for cloud provider to assign)"
    )}
    Port: 5432

    Connect from outside the cluster:
    PGPASSWORD="${var.postgres_password}" psql -h <external-ip-or-hostname> -U ${var.postgres_username} -d ${var.database_name} -p 5432
  EOT
  sensitive = true
}
{{/if}}

output "postgres_connection_string" {
  description = "PostgreSQL connection string (JDBC format)"
  value       = "postgresql://${var.postgres_username}@${helm_release.postgres.name}.${helm_release.postgres.namespace}.svc.cluster.local:5432/${var.database_name}"
  sensitive   = false
}

output "postgres_architecture" {
  description = "PostgreSQL deployment architecture"
  value       = var.architecture
}

{{#if eq architecture "replication"}}
output "postgres_replica_service" {
  description = "PostgreSQL read replica service endpoint"
  value       = "${helm_release.postgres.name}-read.${helm_release.postgres.namespace}.svc.cluster.local:5432"
}

output "postgres_replica_count" {
  description = "Number of PostgreSQL read replicas"
  value       = var.replica_count
}
{{/if}}

{{#if persistence_enabled}}
output "postgres_storage_info" {
  description = "PostgreSQL storage configuration"
  value = {
    size         = var.storage_size
    storageClass = var.storage_class != "" ? var.storage_class : "default"
    enabled      = var.persistence_enabled
  }
}
{{/if}}

{{#if metrics_enabled}}
output "postgres_metrics_enabled" {
  description = "Prometheus metrics status"
  value       = "Metrics enabled on port 9187"
}
{{/if}}

output "postgres_status" {
  description = "Status of the PostgreSQL Helm release"
  value       = helm_release.postgres.status
}

output "connection_commands" {
  description = "Commands to connect to PostgreSQL"
  value = <<-EOT
    # Get the PostgreSQL password
    export POSTGRES_PASSWORD=$(kubectl get secret --namespace ${helm_release.postgres.namespace} ${helm_release.postgres.name}-postgresql -o jsonpath="{.data.postgres-password}" | base64 -d)

    # Connect to PostgreSQL using kubectl port-forward
    kubectl port-forward --namespace ${helm_release.postgres.namespace} svc/${helm_release.postgres.name}-postgresql 5432:5432

    # In another terminal, connect with psql
    PGPASSWORD="$POSTGRES_PASSWORD" psql --host 127.0.0.1 -U ${var.postgres_username} -d ${var.database_name} -p 5432

    # Or connect from within the cluster
    kubectl run ${helm_release.postgres.name}-client --rm --tty -i --restart='Never' --namespace ${helm_release.postgres.namespace} --image docker.io/bitnami/postgresql:16 --env="PGPASSWORD=$POSTGRES_PASSWORD" --command -- psql --host ${helm_release.postgres.name}-postgresql -U ${var.postgres_username} -d ${var.database_name} -p 5432
  EOT
}

output "postgres_management_commands" {
  description = "Useful PostgreSQL management commands"
  value = <<-EOT
    # List all databases
    PGPASSWORD="$POSTGRES_PASSWORD" psql -h 127.0.0.1 -U ${var.postgres_username} -d postgres -c "\\l"

    # List all tables in ${var.database_name}
    PGPASSWORD="$POSTGRES_PASSWORD" psql -h 127.0.0.1 -U ${var.postgres_username} -d ${var.database_name} -c "\\dt"

    # Check PostgreSQL version
    PGPASSWORD="$POSTGRES_PASSWORD" psql -h 127.0.0.1 -U ${var.postgres_username} -d ${var.database_name} -c "SELECT version();"

    # View active connections
    PGPASSWORD="$POSTGRES_PASSWORD" psql -h 127.0.0.1 -U ${var.postgres_username} -d ${var.database_name} -c "SELECT * FROM pg_stat_activity;"

    # Create a database backup
    PGPASSWORD="$POSTGRES_PASSWORD" pg_dump -h 127.0.0.1 -U ${var.postgres_username} -d ${var.database_name} -F c -f backup_$(date +%Y%m%d_%H%M%S).dump

    # Restore from backup
    PGPASSWORD="$POSTGRES_PASSWORD" pg_restore -h 127.0.0.1 -U ${var.postgres_username} -d ${var.database_name} -F c backup_file.dump
  EOT
}

{{#if eq architecture "replication"}}
output "replication_info" {
  description = "PostgreSQL replication information"
  value = <<-EOT
    Primary endpoint: ${helm_release.postgres.name}-postgresql.${helm_release.postgres.namespace}.svc.cluster.local:5432
    Read replica endpoint: ${helm_release.postgres.name}-postgresql-read.${helm_release.postgres.namespace}.svc.cluster.local:5432

    Use the primary endpoint for write operations and read replica endpoint for read operations to distribute load.
  EOT
}
{{/if}}

output "security_notes" {
  description = "Important security information"
  value = <<-EOT
    IMPORTANT SECURITY NOTES:
    1. The password is stored in a Kubernetes secret: ${helm_release.postgres.name}-postgresql
    2. Change the default password in production environments
    3. Consider using cert-manager for TLS certificates
    4. Use network policies to restrict access to the database
    5. Enable backup solutions for production databases
    6. Consider using a secrets management solution like Vault
  EOT
}
