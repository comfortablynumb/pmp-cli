terraform {
  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.11"
    }
  }
}

provider "kubernetes" {
  config_path = "~/.kube/config"
}

provider "helm" {
  kubernetes {
    config_path = "~/.kube/config"
  }
}

{{#if create_namespace}}
resource "kubernetes_namespace" "postgres" {
  metadata {
    name = var.namespace
    labels = {
      name    = var.namespace
      managed = "opentofu"
      project = "{{name}}"
    }
  }
}
{{/if}}

resource "helm_release" "postgres" {
  name       = "postgres"
  repository = "https://charts.bitnami.com/bitnami"
  chart      = "postgresql"
  version    = var.chart_version
  namespace  = var.namespace

{{#if create_namespace}}
  depends_on = [kubernetes_namespace.postgres]
{{/if}}

  values = [
    yamlencode({
      global = {
        postgresql = {
          auth = {
            username      = var.postgres_username
            password      = var.postgres_password
            database      = var.database_name
            existingSecret = ""
          }
        }
      }

      architecture = var.architecture

      auth = {
        username      = var.postgres_username
        password      = var.postgres_password
        database      = var.database_name
        existingSecret = ""
      }

      primary = {
        persistence = {
          enabled      = var.persistence_enabled
          size         = var.storage_size
          storageClass = var.storage_class != "" ? var.storage_class : null
        }

        resources = {
          requests = {
            cpu    = var.resources_requests_cpu
            memory = var.resources_requests_memory
          }
          limits = {
            cpu    = var.resources_limits_cpu
            memory = var.resources_limits_memory
          }
        }

        service = {
          type = var.service_type
        }

        {{#if metrics_enabled}}
        podAnnotations = {
          "prometheus.io/scrape" = "true"
          "prometheus.io/port"   = "9187"
        }
        {{/if}}
      }

      {{#if eq architecture "replication"}}
      readReplicas = {
        replicaCount = var.replica_count

        persistence = {
          enabled      = var.persistence_enabled
          size         = var.storage_size
          storageClass = var.storage_class != "" ? var.storage_class : null
        }

        resources = {
          requests = {
            cpu    = var.resources_requests_cpu
            memory = var.resources_requests_memory
          }
          limits = {
            cpu    = var.resources_limits_cpu
            memory = var.resources_limits_memory
          }
        }

        service = {
          type = var.service_type
        }
      }
      {{/if}}

      {{#if metrics_enabled}}
      metrics = {
        enabled = true
        serviceMonitor = {
          enabled = false
        }
        resources = {
          requests = {
            cpu    = "50m"
            memory = "64Mi"
          }
          limits = {
            cpu    = "100m"
            memory = "128Mi"
          }
        }
      }
      {{/if}}

      volumePermissions = {
        enabled = true
      }

      # PostgreSQL configuration
      postgresqlConfiguration = {
        max_connections           = "200"
        shared_buffers            = "128MB"
        effective_cache_size      = "512MB"
        maintenance_work_mem      = "64MB"
        checkpoint_completion_target = "0.9"
        wal_buffers               = "16MB"
        default_statistics_target = "100"
        random_page_cost          = "1.1"
        effective_io_concurrency  = "200"
        min_wal_size              = "1GB"
        max_wal_size              = "4GB"
      }
    })
  ]

  # Wait for deployment to be ready
  wait    = true
  timeout = 600
}
