terraform {
  required_providers {
    postgresql = {
      source  = "cyrilgdn/postgresql"
      version = "~> 1.22"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.6"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }
  }
}

# PostgreSQL provider configuration
# Note: Connection details should be provided via environment variables or provider config
provider "postgresql" {
  # Expected environment variables:
  # PGHOST, PGPORT, PGUSER, PGPASSWORD, PGDATABASE, PGSSLMODE
  # Or configure explicitly in parent template
}

provider "random" {}

provider "kubernetes" {
  config_path = "~/.kube/config"
}

# Generate secure random password if not provided
resource "random_password" "role_password" {
  count = var.role_password == "" ? 1 : 0

  length  = 32
  special = true
  upper   = true
  lower   = true
  numeric = true
}

locals {
  # Use provided password or generated one
  actual_password = var.role_password != "" ? var.role_password : random_password.role_password[0].result

  # Determine database name (use provided or fall back to database_name variable)
  actual_database = var.database_name != "" ? var.database_name : "{{database_name}}"

  # Determine namespace for K8s secret
  actual_namespace = var.k8s_secret_namespace != "" ? var.k8s_secret_namespace : "{{namespace}}"

  # Generate secret name if not provided
  actual_secret_name = var.k8s_secret_name != "" ? var.k8s_secret_name : "postgres-credentials-${var.role_name}"

  # Convert privileges array to format expected by PostgreSQL
  # Valid privileges: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, ALL
  privileges_list = var.privileges
}

# Create PostgreSQL role
resource "postgresql_role" "user" {
  name     = var.role_name
  login    = true
  password = local.actual_password

  # Role attributes
  superuser         = var.superuser
  create_database   = var.create_db
  create_role       = var.create_role
  connection_limit  = var.connection_limit

  # Password expiration
  valid_until = var.valid_until != "" ? var.valid_until : null

  # Lifecycle
  lifecycle {
    ignore_changes = [
      # Don't force password rotation on every apply
      password,
    ]
  }
}

# Grant schema privileges
resource "postgresql_grant" "schema" {
  count = var.create_schema ? 1 : 0

  database    = local.actual_database
  role        = postgresql_role.user.name
  schema      = var.schema_name
  object_type = "schema"
  privileges  = ["CREATE", "USAGE"]
}

# Grant table privileges
resource "postgresql_grant" "tables" {
  database    = local.actual_database
  role        = postgresql_role.user.name
  schema      = var.schema_name
  object_type = "table"
  privileges  = local.privileges_list

  # Grant on all existing tables
  with_grant_option = var.grant_option
}

# Grant sequence privileges (needed for INSERT with auto-increment)
resource "postgresql_grant" "sequences" {
  count = contains(local.privileges_list, "INSERT") || contains(local.privileges_list, "UPDATE") || contains(local.privileges_list, "ALL") ? 1 : 0

  database    = local.actual_database
  role        = postgresql_role.user.name
  schema      = var.schema_name
  object_type = "sequence"
  privileges  = ["SELECT", "UPDATE", "USAGE"]

  with_grant_option = var.grant_option
}

# Grant function privileges
resource "postgresql_grant" "functions" {
  count = contains(local.privileges_list, "SELECT") || contains(local.privileges_list, "ALL") ? 1 : 0

  database    = local.actual_database
  role        = postgresql_role.user.name
  schema      = var.schema_name
  object_type = "function"
  privileges  = ["EXECUTE"]

  with_grant_option = var.grant_option
}

# Set default privileges for future tables
resource "postgresql_default_privileges" "tables" {
  database    = local.actual_database
  role        = postgresql_role.user.name
  schema      = var.schema_name
  owner       = "postgres"  # Adjust if using different owner
  object_type = "table"
  privileges  = local.privileges_list

  with_grant_option = var.grant_option
}

# Set default privileges for future sequences
resource "postgresql_default_privileges" "sequences" {
  count = contains(local.privileges_list, "INSERT") || contains(local.privileges_list, "UPDATE") || contains(local.privileges_list, "ALL") ? 1 : 0

  database    = local.actual_database
  role        = postgresql_role.user.name
  schema      = var.schema_name
  owner       = "postgres"  # Adjust if using different owner
  object_type = "sequence"
  privileges  = ["SELECT", "UPDATE", "USAGE"]

  with_grant_option = var.grant_option
}

{{#if create_k8s_secret}}
# Create Kubernetes secret with database credentials
resource "kubernetes_secret" "db_credentials" {
  metadata {
    name      = local.actual_secret_name
    namespace = local.actual_namespace

    labels = {
      "app.kubernetes.io/name"       = "postgresql"
      "app.kubernetes.io/component"  = "database-credentials"
      "app.kubernetes.io/managed-by" = "opentofu"
      "pmp.io/role"                  = var.role_name
    }

    annotations = {
      "pmp.io/database"    = local.actual_database
      "pmp.io/schema"      = var.schema_name
      "pmp.io/privileges"  = join(",", local.privileges_list)
      "pmp.io/created-at"  = timestamp()
    }
  }

  data = {
    username          = var.role_name
    password          = local.actual_password
    database          = local.actual_database
    host              = "{{name}}-postgresql.{{namespace}}.svc.cluster.local"
    port              = "5432"
    schema            = var.schema_name
    connection-string = "postgresql://${var.role_name}:${local.actual_password}@{{name}}-postgresql.{{namespace}}.svc.cluster.local:5432/${local.actual_database}"
    jdbc-url          = "jdbc:postgresql://{{name}}-postgresql.{{namespace}}.svc.cluster.local:5432/${local.actual_database}"
  }

  type = "Opaque"
}
{{/if}}
