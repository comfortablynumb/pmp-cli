terraform {
  required_version = ">= 1.0"

  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }
  }
}

provider "kubernetes" {
  config_path = "~/.kube/config"
}

# Read environment metadata for plugin integration
data "local_file" "env_metadata" {
  filename = "${path.module}/.pmp.environment.yaml"
}

locals {
  # Parse environment YAML to get added plugins
  env_data      = yamldecode(data.local_file.env_metadata.content)
  added_plugins = try(local.env_data.spec.plugins.added, [])

  # Collect plugin environments from all added plugin modules
  plugin_environments = merge([
    for plugin in local.added_plugins :
    try(
      module["${plugin.template_pack_name}_${plugin.name}_${plugin.project.name}"].environments,
      {}
    )
  ]...)
}

# Create namespace for the application
resource "kubernetes_namespace" "app" {
  metadata {
    name = "{{name}}"
    labels = {
      "app.kubernetes.io/name"       = "{{name}}"
      "app.kubernetes.io/managed-by" = "pmp"
    }
  }
}

# Deployment for the HTTP API
resource "kubernetes_deployment" "app" {
  metadata {
    name      = "{{name}}"
    namespace = kubernetes_namespace.app.metadata[0].name
    labels = {
      "app.kubernetes.io/name"       = "{{name}}"
      "app.kubernetes.io/component"  = "api"
      "app.kubernetes.io/managed-by" = "pmp"
    }
  }

  spec {
    replicas = var.min_replicas

    selector {
      match_labels = {
        "app.kubernetes.io/name"      = "{{name}}"
        "app.kubernetes.io/component" = "api"
      }
    }

    template {
      metadata {
        labels = {
          "app.kubernetes.io/name"      = "{{name}}"
          "app.kubernetes.io/component" = "api"
        }
      }

      spec {
        container {
          name  = "api"
          image = "${var.docker_image}:${var.version}"

          port {
            name           = "http"
            container_port = var.http_port
            protocol       = "TCP"
          }

          # Resource requests and limits (Guaranteed QoS)
          resources {
            requests = {
              cpu    = "${var.cpu_millicores}m"
              memory = "${var.memory_mb}Mi"
            }
            limits = {
              cpu    = "${var.cpu_millicores}m"
              memory = "${var.memory_mb}Mi"
            }
          }

          # Startup probe - allows container time to start
          startup_probe {
            http_get {
              path   = var.healthcheck_uri
              port   = var.http_port
              scheme = "HTTP"
            }
            initial_delay_seconds = 5
            period_seconds        = 5
            timeout_seconds       = 3
            failure_threshold     = 12
            success_threshold     = 1
          }

          # Liveness probe - restarts container if unhealthy
          liveness_probe {
            http_get {
              path   = var.healthcheck_uri
              port   = var.http_port
              scheme = "HTTP"
            }
            initial_delay_seconds = 0
            period_seconds        = 10
            timeout_seconds       = 3
            failure_threshold     = 3
            success_threshold     = 1
          }

          # Inject environment variables from plugins
          dynamic "env" {
            for_each = local.plugin_environments

            content {
              name = env.key

              # If the environment variable comes from a secret
              dynamic "value_from" {
                for_each = lookup(env.value, "secret_name", null) != null ? [1] : []

                content {
                  secret_key_ref {
                    name = env.value.secret_name
                    key  = env.value.secret_key
                  }
                }
              }

              # If the environment variable is a direct value
              value = lookup(env.value, "secret_name", null) == null ? lookup(env.value, "value", "") : null
            }
          }
        }
      }
    }
  }
}

# Service to expose the HTTP API
resource "kubernetes_service" "app" {
  metadata {
    name      = "{{name}}"
    namespace = kubernetes_namespace.app.metadata[0].name
    labels = {
      "app.kubernetes.io/name"       = "{{name}}"
      "app.kubernetes.io/component"  = "api"
      "app.kubernetes.io/managed-by" = "pmp"
    }
  }

  spec {
    type = var.service_type

    selector = {
      "app.kubernetes.io/name"      = "{{name}}"
      "app.kubernetes.io/component" = "api"
    }

    port {
      name        = "http"
      port        = var.http_port
      target_port = var.http_port
      protocol    = "TCP"
    }
  }
}

# HorizontalPodAutoscaler for auto-scaling
resource "kubernetes_horizontal_pod_autoscaler_v2" "app" {
  metadata {
    name      = "{{name}}"
    namespace = kubernetes_namespace.app.metadata[0].name
    labels = {
      "app.kubernetes.io/name"       = "{{name}}"
      "app.kubernetes.io/component"  = "api"
      "app.kubernetes.io/managed-by" = "pmp"
    }
  }

  spec {
    min_replicas = var.min_replicas
    max_replicas = var.max_replicas

    scale_target_ref {
      api_version = "apps/v1"
      kind        = "Deployment"
      name        = kubernetes_deployment.app.metadata[0].name
    }

    metric {
      type = "Resource"
      resource {
        name = "cpu"
        target {
          type                = "Utilization"
          average_utilization = 80
        }
      }
    }

    behavior {
      scale_down {
        stabilization_window_seconds = 300
        policy {
          type          = "Percent"
          value         = 50
          period_seconds = 60
        }
      }
      scale_up {
        stabilization_window_seconds = 0
        policy {
          type          = "Percent"
          value         = 100
          period_seconds = 30
        }
        policy {
          type          = "Pods"
          value         = 2
          period_seconds = 30
        }
        select_policy = "Max"
      }
    }
  }
}

# PodDisruptionBudget to ensure availability during disruptions
resource "kubernetes_pod_disruption_budget_v1" "app" {
  metadata {
    name      = "{{name}}"
    namespace = kubernetes_namespace.app.metadata[0].name
    labels = {
      "app.kubernetes.io/name"       = "{{name}}"
      "app.kubernetes.io/component"  = "api"
      "app.kubernetes.io/managed-by" = "pmp"
    }
  }

  spec {
    max_unavailable = "1"

    selector {
      match_labels = {
        "app.kubernetes.io/name"      = "{{name}}"
        "app.kubernetes.io/component" = "api"
      }
    }
  }
}
